/* ******************************************************************************
 *
 * Font Stacks
 *
 * We should set up our font stacks in the variables file. Then, when we want to 
 * set our font on a selector we call the family, weight and style in the mixin.
 *
 ****************************************************************************** */

@mixin font($font-family: $helvetica, $weight: 500, $style: normal) {
  font-family: $font-family;
  font-style: $style;
  font-weight: $weight;
}

/* ******************************************************************************
 *
 * Retina Images
 *
 * Smart delivery of 2x images for those cases where svg just won't work. 
 * http://37signals.com/svn/posts/3271-easy-retina-ready-images-using-scss
 *
 ****************************************************************************** */

@mixin image-2x($image, $width, $height) {
  @media (min--moz-device-pixel-ratio: 1.3),
         (-o-min-device-pixel-ratio: 2.6/2),
         (-webkit-min-device-pixel-ratio: 1.3),
         (min-device-pixel-ratio: 1.3),
         (min-resolution: 1.3dppx) {
    /* on retina, use image that's scaled by 2 */
    background-image: url($image);
    background-size: $width $height;
  }
}

/* ******************************************************************************
 *
 * Media Queries
 *
 * We'll change the values/if statements on a case by case basis. But, the idea
 * is the same, get our sized breakpoints and stick them in as mixins. This way
 * if we need to change breakpoints we can do so once. We also don't have to
 * remember specific values.
 *
 ****************************************************************************** */

@mixin breakpoint($point) {
  @if $point == small {
    @media (min-width: pem(480)) { @content; }
  }
  @if $point == medium {
    @media (min-width: pem(800)) { @content; }
  }
  @if $point == large {
    @media (min-width: pem(1000)) { @content; }
  }
  @if $point == x-large {
    @media (min-width: pem(1200)) { @content; }
  }
  @if $point == reverse-small {
    @media (max-width: pem(480)) { @content; }
  }
  @if $point == reverse-medium {
    @media (max-width: pem(800)) { @content; }
  }
  @if $point == reverse-large {
    @media (max-width: pem(1000)) { @content; }
  }
  @if $point == reverse-x-large {
    @media (max-width: pem(1200)) { @content; }
  }
}

/* ******************************************************************************
 *
 * Buttons
 *
 * We'll most likely be rewriting this, often, but the idea is to build it so
 * that all we pass is a single color. Compass will determine if it should
 * darken or lighten it, and send the right colors as a result. We can also set
 * up variable border-radius.
 *
 ****************************************************************************** */

@mixin button($color: #818181, $border-radius: $default-border-radius) {
  @include single-transition;
  @include border-radius($border-radius);
  @include box-shadow(0 1px 2px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.25));
  @include background(linear-gradient(top, contrast-color($color, $color, lighten($color, 20%), 50%), contrast-color($color, darken($color, 20%), $color, 50%)));
  background-color: $color;
  background-repeat: repeat-x;
  border: 1px solid contrast-color($color, darken($color, 30%), darken($color, 10%), 50%);
  color: contrast-color($color, #000, #fff, 50%);
  font-weight: bold;
  text-shadow: 0 1px 1px contrast-color($color, rgba(255,255,255,0.5), rgba(0,0,0,0.5), 50%);
  &:hover,
  &:focus {
    background-color: $color;
    background-position: 0 -15px;
    color: contrast-color($color, #000, #fff, 50%);
  }
  &:active {
    @include box-shadow(inset 0 1px 1px rgba(0,0,0,0.25));
    @include single-transition(all, 0s, linear);
    border-bottom: 1px solid lighten($color, 30%);
  }
}

/* ******************************************************************************
 *
 * Text Utilities
 *
 * Easy addition of text-overflow ellipsis or word-wrap properties. Don't use, 
 * @include ellipsis/word-wrap. Rather, use @extend %ellipsis/%word-wrap as this
 * will get all of the items using this on the same selector.
 *
 ****************************************************************************** */

@mixin ellipsis {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

@mixin word-wrap {
  -ms-word-break: break-all;
  word-break: break-all;
  word-break: break-word;
  -webkit-hyphens: auto;
  -moz-hyphens: auto;
  hyphens: auto;
}

/* ******************************************************************************
 *
 * Embossed/Letterpressed box
 *
 * Don't use, @include box-emboss. Rather, use @extend %box-emboss as this will
 * get all of the items using this on the same selector.
 *
 ****************************************************************************** */

@mixin box-emboss($outerOpacity: 0.3, $innerOpacity: 0.6) {
  @include box-shadow(rgba(white, $outerOpacity) 0 1px 0, rgba(black, $innerOpacity) 0 1px 0 inset);
}

/* ******************************************************************************
 *
 * CSS Animations
 *
 * Set up @include keyframes(name-of-keyframes) ourside of a selector context.
 * This will allow us to use the keyframes in animation. Should do this early on
 * in the sass stack. Then we use the animation mixin in the selector we need to
 * animate, calling in the (name, duration, transition-direction, repeat, etc.)
 * See "Animation Mixin" here: http://css-tricks.com/custom-user-mixins/
 *
 ****************************************************************************** */

@mixin keyframes($name) {
  @-webkit-keyframes #{$name} {
    @content
  }
  @-moz-keyframes #{$name} {
    @content
  }
  @-ms-keyframes #{$name} {
    @content
  }
  @-o-keyframes #{$name} {
    @content
  }
  @keyframes #{$name} {
    @content
  }
}

@mixin animation($value) {
  -webkit-animation: $value;
  -moz-animation: $value;
  -ms-animation: $value;
  -o-animation: $value;
  animation: $value;
}

/* ******************************************************************************
 *
 * Site specific mixins
 *
 * Every site is a beautiful and unique snowflake. Create your beautiful and 
 * unique mixins here.
 *
 ****************************************************************************** */
